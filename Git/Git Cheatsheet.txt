# Initialize a local repository
	## git init
	## git clone

# Managing remote repositories

	## Adding a remote repository
	git remote add <remote-name> <url>
	eg:
		$ git remote add origin https://github.com/user/repo.git

		$ git remote -v
		> origin  https://github.com/user/repo.git (fetch)
		
	## git remote rename
	## git remote remove
	## git remote set-url <An existing remote name> <url>

# git push
	## set upstream of a branch
		git push --set-upstream origin my-feature
			local branch my-feature is associated with upstream branch origin/my-feature
		git push
			if you are on my-feature branch, it will push to origin/my-feature which is the upstream branch
	## git push <remote-name> <local-branch>[:remote-branch]
		git push origin feature
			local branch feature will be pushed to origin/feature (same name as default)
	## git push -u origin feature
		if the remote branch doesn't exist yet
	## --force (force to overwrite existing branch)

# git branch
	## check branches
		### local:
		$ git branch
			  master
			* my-feature
			  feature
		### remote:
		$ git branch -r
			origin/main
			origin/feature1
			origin/debug2
			remote-repo/main
			remote-repo/other-feature
		### all:
		$ git branch -a
	## create a branch without checking it out
		### local:
			git branch <branch>
				Create a new branch called ＜branch＞. This does not check out the new branch.
		### remote:
			create a local branch and then push it
			git push <remote> <branch>
	## create a branch and check it out
		git checkout -b <branch-name>
	## delete a branch
		## git branch -d <branch>
			Delete the specified branch. This is a “safe” operation in that Git prevents you from deleting the branch if it has unmerged changes.
		## git branch -D <branch>
			Force delete the specified branch, even if it has unmerged changes. This is the command to use if you want to permanently throw away all of the commits associated with a particular line of development.

		### local:
			git branch -D branch_name
		### remote:
			git push origin --delete <branch_name>
				or
			git push origin :<branch_name>

	## rename a branch
		git branch -m <branch>
			Rename the current branch to ＜branch＞.

# git fetch
	## git fetch <remote>
		fetch all branches from remote
	## git fetch <remote> <branch>
		fetch specified branch from remote

# git merge
	## git merge <branch-name>
		branch-name can either be local branch or remote branch (which is already downloaded), it's then merged to head (head is always the receiving side)
	## Fast Forward Merge:
		The merging side is linerly ahead of the receiving side
	## Three-way Merge:
		The main progresses while the feature is in-progress, to resolve merge conflicts, use edit/stage/commit workflow. The files of conflict will first be in the working tree, after you resolve that, stage it (git add <conflicted files> and then commit <git commit> the staging index.
		
	## How conflicts are presented
		When Git encounters a conflict during a merge, It will edit the content of the affected files with visual indicators that mark both sides of the conflicted content. These visual markers are: <<<<<<<, =======, and >>>>>>>. Its helpful to search a project for these indicators during a merge to find where conflicts need to be resolved.

		here is some content not affected by the conflict
		<<<<<<< main
		this is conflicted text from main
		=======
		this is conflicted text from feature branch
		>>>>>>> feature branch;
		Generally the content before the ======= marker is the receiving branch and the part after is the merging branch.
		

# git checkout vs git reset
	## git checkout <branch-name>/[checksum/head]
		git checkout only moves the head ref to the specified checksum
			If the head is not associated with a local branch, then the head is detached, you need to attach a local branch to that head.
		git checkout -b <local-branch-name>
			create a local branch and check it out at current head.
	## git reset <branch-name>/[checksum/head]
		moves the current branch and ref head to the specified checksum
		git reset
			is equivalent to:
		git reset --mixed head
		### --hard
			move head and branch ref, the Staging Index and the Working Directory are both cleared.
		### --mixed
			move head and branch ref, changes in staging index move back to working directory.
		### --soft
			move head and branch ref, the Staging Index and the Working Directory are left untouched

# Stage (working tree, staging index, local commit)
	## stage
		git add ./<file>
	## unstage, unstage changes from staging index to working tree
		### all:
			git reset
		git reset <file>
	## check changed files between the working tree and the staging index
		git status
	## commit
		git commit

# git commit
	## git commit -a
		Commit a snapshot of all changes in the working directory. This only includes modifications to tracked files (those that have been added with git add at some point in their history).

	## git commit -m "commit message"
		A shortcut command that immediately creates a commit with a passed commit message. By default, git commit will open up the locally configured text editor, and prompt for a commit message to be entered. Passing the -m option will forgo the text editor prompt in-favor of an inline message.
	## git commit -am "commit message"
		A power user shortcut command that combines the -a and -m options. 
	## git commit --amend
		It will modify the last commit, instead of creating a new commit.

# git diff
	git diff is a multi-use Git command that when executed runs a diff function on Git data sources. These data sources can be commits, branches, files and more. The git diff command is often used along with git status and git log to analyze the current state of a Git repo.
	## git diff file
		### git diff HEAD ./path/to/file
			it will compare the specific changes in the working directory, against the index, showing the changes that are not staged yet. By default git diff will execute the comparison against HEAD. Omitting HEAD in the example above git diff ./path/to/file has the same effect.
		### git diff HEAD --cached ./path/to/file
			the diff will compare the staged changes with the local repository. The --cached option is synonymous with --staged.
		### git diff HEAD
			compare all files between working directory against the index
		### git diff 957fbc92b123030c389bf8b4b874522bdf2db72c ce489262a1ee34340440e55a0b99ea6918e19e7a
			Comparing files between two different commits
		### git diff <branch1> <branch2>

# git log
	Show all local commits under current branch
	git log --graph --oneline --decorate
	git log

# git stash
	The git stash command takes away your uncommitted changes (both staged and unstaged), saves them away for later use.
		By default, running git stash will stash:
			changes that have been added to your index (staged changes)
			changes made to files that are currently tracked by Git (unstaged changes)
		But it will not stash:
			new files in your working copy that have not yet been staged
			files that have been ignored
	# git stash
		Save your staged and unsaged changes to the top of the stash
	# git stash pop
		Popping your stash removes the changes from your stash and reapplies them
	# git stash apply
		apply from the top your stash and reapplies them
	# git stash list
	# git stash save "add style to our site"
		When stashing, add a message
	# git stash pop stash@{2}
		Specify which stash to pop (apply)
	# Creating a branch from your stash
		git stash branch add-stylesheet stash@{1}
		If the changes on your branch diverge from the changes in your stash, you may run into conflicts when popping or applying your stash. This checks out a new branch based on the commit that you created your stash from, and then pops your stashed changes onto it.
	# Cleaning up your stash
		## If you decide you no longer need a particular stash, you can delete it with git stash drop:
		git stash drop stash@{1}
		Dropped stash@{1} (17e2697fd8251df6163117cb3d58c1f62a5e7cdb)

		## delete all of your stashes with:
		git stash clear