    After an object is stored using hashcode like set or map, the signature shouldn't really be touched then. Or that object can't be found using hashcode.
	### For example:
	public static void main(String[] args) {
        // TODO Auto-generated method stub
        Set<Test> set = new HashSet<>();
        Test a = new Test(20);
        set.add(a);
        System.out.println(set.contains(a));			-> true
        a.setId(100);
        System.out.println(set.contains(a));			-> false (Since when first stored, it sued 20 to calculate the hashcode to determin location in hash but then it's changed to 100, calculated hashcode differs)
    }

    public static class Test {
        private Integer id;

        public Test(Integer id) {
            this.id = id;
        }

        public void setId(Integer id) {
            this.id = id;
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Test other = (Test) obj;
            return Objects.equals(id, other.id);
        }

    }
	
	### This example uses the default implementation to use reference to calculate equals and hashcode.
	public static void main(String[] args) {
        // TODO Auto-generated method stub
        Set<Test> set = new HashSet<>();
        Test a = new Test(20);
        set.add(a);
        System.out.println(set.contains(a));	-> true
        a.setId(100);
        System.out.println(set.contains(a));	-> true (since reference isn't changed)
    }

    public static class Test {
        private Integer id;

        public Test(Integer id) {
            this.id = id;
        }

        public void setId(Integer id) {
            this.id = id;
        }
    }