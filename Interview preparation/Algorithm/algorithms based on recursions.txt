All recursions have following steps:
(1) base cases
(2) transition functions (对于递归算法，最重要的就是明确递归函数的定义)
	递归的思想相对迭代思想，稍微有点难以理解，处理的技巧是：不要跳进递归，而是利用明确的定义来实现算法逻辑。

Difference on details deriving from algorithms
(1) divide and conquer (recursion without overlapping sub-problems)
	just recursion, no overlapping sub problems.
in recursive function, in place problem solving, pass initial problem as parameter, return void.

(2) DP
a. base cases
b. transition function. condition, direction. will influence direction from border inward in matrix.
c. tabulation (populate matrix from base cases) / memoization (null if answer of sub-problem not memoized yet)

	DP: recursion + 重复子问题
	// Bottom-up dp problems sovling procedures
	// 1. base cases.
	// 2. transition funciton + condition + direction 
	transition function to derive from base cases, moving from bottom-up. Direction shall be noticed. (condition may affect direction for edge spots)
	// 3. tabulation.
	tabulation by iteration from base cases through direction and fufill the matrix. Need to fill all the matrix to get result.

	// Top-down dp problems sovling procedures
	// 1. base cases
	// 2. transition funciton + condition + direction 
	transition function to derive from base cases, moving from bottom-up. Direction shall be noticed. (condition may affect direction for edge spots)
	// 3. memoization
	memoization (initialize an object matrix, if not set, the object value is null). Written as recursion + memoization.
	Know exactly where the result is in the matrix, then top down.

(3) Tree structure algorithm (Traverse, divide and conqure)
a. traverse
	Depending if the base solution is on the leaves or not: Breath first search, Depth first search

	Depth first search:
		i. recursion, always think and achieve in this way first.
			general workflow:		NLNRN
				at the place of leaves, check it (N), check left and return something(L), do something (N), check right and return something(R), do something like set(N)
				preorder: NLR
				inorder: LNR
				postorder: LRN
		ii. Stack
			Iterative, to transfrom from the corresponding recursive solution.
			general workflow:		use stack to push and pop nodes. If use non-recursion to achieve NLNRN, it's gonna to so hard.

				preorder:		when a node is popped, do something on it and push its right, push its left.
				inorder:		when a node is popped the first time, if its left and right are both null or its mark is 2, do something, else push its right, push itself and mark push times to 2 and push left.
				postorder:	when a node is popped the first time, if its left and right are both null or its mark is 2, do something, else push itslef and mark push time to 2, push its right, push its left.
	Breath first search:
		Queue

b. divide and conquer
	eg: height of a tree

Since connection among nodes will be re-constructed, usually root is returned in recursive functions.


(4) Backtracking
Enumerate (Traverse) over all valid nodes, result is got when reaching a leaf node.

transition function:
	prefix path and choice list and (result) are passed in the transition function.

when recursively called, go one level deeper.
if multiple choices in one level, apply choice before going deeper and revert that choice after getting back

result = []
def backtrack(路径, [选择列表参数], result):
	if 满足结束条件 (reach leaf node):
		result.add(路径)
		return
	for 选择 in 选择列表:
		// filter out invalid choice
		if (choice is invalid) {
			continue;
		}
		做选择
		backtrack(路径, [选择列表参数], result)   -> one level deeper
		撤销选择 (if no more following choices, then this is not needed)

每一层都有已经走过的路径和选择列表，有时候选择列表要依靠选择列表参数来生成
